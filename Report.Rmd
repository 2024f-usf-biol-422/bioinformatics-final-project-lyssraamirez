---
title: 'Analyzing SARS-CoV-2 in Pennsylvania Wastewater Samples: SNP Distribution, Temporal Trends, and Correlation with Population'
author: "Alyssa Ramirez"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
csl: bioinformatics.csl
bibliography: references.bib
params:
  gff_file_path: "data/metadata/sars_refgenome_annotation.gff"
  vcf_dir_path: "data/11_vcf_output_for_R"
  sra_runtable_path: "data/00_sra_runtable/SraRunTable.csv"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      error = FALSE)
```

# Background and Overview
The monitoring and detection of SARS-CoV-2 RNA in water waste have emerged as another tool in aiding the surveillance of COVID-19 in populations. Water Waste surveillance provides non-invasive, cost-effective methods for  insights and trends in the spread in asymptomatic individuals. This approach has been useful in understanding hotspots, trends and other helpful insights that aid public health. Water waste surveillance also shows the evolutionary trends of SARS-CoV-2 strain advancements.
This study utilizes Pennsylvania Waterwaste Surveillance systems (PAWSS) data, a statewide surveillance system that collects waste samples in diverse communities. The dataset includes metadata from Pennsylvania communities. Specifically data such as population sizes, sequencing information, temporal trends and sample collecting methods. PAWSS provides a comprehensive framework to evaluate temporal and spatial trends in SARS-CoV-2 prevalence across urban and rural regions of Pennsylvania.

Multiple factors influence the effectiveness and reliability of SARS-CoV-2 detection in wastewater samples. Specific sampling methods and collection times are crucial, as they can affect the concentration and virality of RNA. For example, composite samples may yield more data compared to grab samples, while collection during its peak viral periods may capture higher RNA levels. On the other hand, size of the population served by a wastewater treatment surveillance system can play a significant role in determining viral RNA detection. Larger populations may induce dilute viral signs due to wastewater volume, whereas smaller populations may achieve statistically significant viral RNA trends.

The primary goal of this study is to evaluate how collection periods, sampling methods, genome evolution and population size impact SARS-CoV-2 RNA detection in wastewater. By using sequencing metadata on population size and time collecting samples, this analysis seeks to uncover trends and identify viral RNA strains in the reliability of the PAWSS. By normalizing sequence coverage and assessing temporal patterns, this study aims to contribute to the public health.




# Methods
Wastewater samples were collected from various locations across Pennsylvania from the Pennsylvania Wastewater Surveillance System (PAWSS). Samples were gathered at different times using both composite and grab sampling methods. Composite samples were collected over a duration of 24 hours and is more of an average of the samples. As the grab samples were a one time or single time collection. Viral RNA was extracted from the wastewater samples using surveillance protocols, which are first filtration, then concentration, and lastly RNA purification processes. After the RNA was purified, reverse-transcribed to cDNA using Reverse Transcription Polymerase Chain Reaction (RT-PCR), which converts the RNA into DNA for sequencing. The cDNA was then sequenced. Sequencing and tabular data are part of the set from PAWSS.The GFF annotations and VCF files were processed to extract SNP data and other relevant data within the metadata.

Data was then cleaned and sorted out of the raw dataset. The pipeline was used to filter in the clean data.The pipeline used call functions to work cleanly;read_gff: Read and parsed the GFF genome annotation file to extract genomic regions of interest.;extract_genes_from_gff: Filtered and cleaned the GFF data to produce a gene table containing genomic coordinates and gene names.;parse_tidy_and_stack_vcfs: Processed and combined multiple VCF files into a single tidy dataset, adding sample-specific metadata.;add_genes_metadata_to_vcfstack: Annotated SNPs with gene information by merging the tidy VCF data with the cleaned gene table and sequencing metadata.
The PAWWS  was then converted into a sraRuntable to be able to call on in the code. R studio packages were utilized, including “vcfR”, “ggplot2” [@2016ggplot2], “ggthemes”, “knitr” and “dplyr”[@2023dplyr] were used to visualize the data. Figures and tables were generated to illustrate SNP distribution, population trends, temporal patterns, and relationships between variables. Chat Gpt was also used to write the code of figures in this study. Citr[@2020citr] was used for citations.

# Results 
The SNP counts across different genes in Figure 1. show that the S gene has the highest number of SNPs, inferring that the mutation rate in the Pennsylvania region is much higher than any other parts of the viral genome. This is crucial to the virality of the S-genes spike protein that allows for a higher infection rate. Figure 2. Illustrates the relationship between population size and average spot length of sequencing reads with a slight correlation. This scatterplot suggests that the larger populations may contribute to shorter read lengths in SNPs. Potentially due to increasing sample  and RNA complexity. A similar trend was observed in Figure 3. Which illustrates the relationship between population size and RNA detection levels. This scatterplot showed a positive correlation, indicating that larger populations will contribute to be more consistent in RNA detection and viral shedding. An observation of temporal trends is illustrated in Figure 4. Comparing sequence coverage over time in the Pennsylvania region. The plot shows fluctuations in coverage with certain months being observed as high and some as low changes in viral prevalence. The trends could be linked to local SARS-CoV-2 cases, providing valuable insight for public health. In Figure 5. the box plot compares sample matrices of composite and grabs sample data. Composite samples are higher because they reduce temporal variability and provide a more representative picture of SARS-CoV-2 levels. In Figure 6. The bar plot shows the common reference versus alternate genome variants. The counts of variants are classified by reference genome nucleotide (A, C, G, T) and their corresponding alternate genomes. Nucleotide T was the most frequently observed, showing that thymine is the most common variant in the region.  Lastly, table 1. Shows an overall summary of all figure data.

# Discussion
In conclusion, data suggest that sampling methods, population size and temporal trends significantly influence the detection of SARS-CoV-2 in wastewater. When it came down to which sampling method was deemed reliable and most effective, composite samples won over grab samples. Population size and RNA detection did not correlate and had a small role against RNA detection showing trends that were not predicted before going through the data. Although the population size data was not helpful to the  overall study, it was helpful in the visualization of the S genome, seen as the most common in the population. Temporal trends indicated variation over time in sequencing coverage that could possibly reflect changes in the SARS-CoV-2 genome.

```{r load-packages-and-functions}
library("vcfR")
library("ggplot2")
library("dplyr")
library("ggthemes")
library("knitr")
library("grid")
library("gridExtra")

# this loads all function files in the code/functions directory
function_paths <- list.files("code/functions", full.names = TRUE)
purrr::walk(function_paths, source)
```

```{r load-vcf-data}
# load in, tidy, and stack all of the VCF files in the target directory
# these are the output of the bash pipeline
stacked_vcfs <- parse_tidy_and_stack_vcfs(vcf_dir_path = params$vcf_dir_path)

# load in the gff file with genome annotations for SARS-CoV-2
gff <- read_gff(gff_file_path = params$gff_file_path)

# pull out just the named genes from the annotation file
gene_table <- extract_genes_from_gff(annotation_object = gff)

# combine the stacked vcf table with the gene names and the metadata from
# the sra runtable file
vcf_with_metadata <-
  add_genes_metadata_to_vcfstack(sra_runtable_path = params$sra_runtable_path,
                                 stacked_vcf = stacked_vcfs,
                                 cleaned_genes_table = gene_table)
```

# Figures
```{r barplot-SNP-gene-distribution, echo=TRUE, warning=FALSE, message=FALSE, fig.width=10, fig.height=8}
# Group by gene and summarize SNP counts
gene_snp_summary <- vcf_with_metadata %>%
  group_by(gene) %>% # Update this if your gene column has a different name
  summarize(total_snps = n()) %>%
  filter(!is.na(gene))

# Create the bar plot
snp_plot <- ggplot(gene_snp_summary, aes(x = reorder(gene, -total_snps),
                                         y = total_snps, fill = gene)) +
  geom_bar(stat = "identity", alpha = 0.8) +
  labs(
    title = "SNP Counts Across Different Genes",
    x = "Gene",
    y = "SNP Count",
    fill = "Gene"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none" # Hide legend for simplicity
  )

# Display the plot in RStudio
print(snp_plot)

# Save the plot to a file
ggsave(filename = "snp_counts_across_genes.png", plot = snp_plot, width = 10,
       height = 8, dpi = 300)
```
**Figure 1**:Figure: Bar plot showing the number of single nucleotide polymorphisms (SNPs) identified across different genes of SARS-CoV-2. The genes are labeled on the x-axis, and the y-axis indicates the count of SNPs. This figure highlights which genes exhibit the highest mutation frequency, with the S gene having the largest number of SNPs, suggesting greater genetic variability in this region. Such information is crucial for understanding the genetic diversity and evolution of the virus in wastewater samples

```{r figure-1,normalized-sequence-coverage, echo=TRUE, warning=FALSE, message=FALSE}
# Convert Collection_Date to Date format
vcf_with_metadata$Collection_Date <- as.Date(vcf_with_metadata$Collection_Date,
                                             format = "%m/%d/%y")

# Normalize Sequencing Coverage by Population Size and create the plot
normalized_plot <- vcf_with_metadata %>%
  mutate(Bases_per_person = Bases / ww_population) %>%
  ggplot(aes(x = Collection_Date,
             y = Bases_per_person,
             color = geo_loc_name)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Normalized Sequencing Coverage Over Time by Region",
    x = "Collection Date",
    y = "Sequencing Coverage per Person",
    color = "Region"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Display the plot in RStudio
print(normalized_plot)
# Save the plot to a file
ggsave(filename = "normalized_sequencing_coverage.png", plot = normalized_plot,
       width = 10, height = 8, dpi = 300)
```

**Figure 2**:Temporal Trends in Normalized Sequencing Coverage Over Time in Pennsylvania
The plot shows normalized sequencing coverage (SARS-CoV-2 RNA levels per person) over time for wastewater samples collected in Pennsylvania. Peaks in sequencing coverage may reflect variations in viral prevalence, sampling methods, or population size adjustments. The data are normalized to account for differences in population size represented by each sample.

```{r population-vs-rna-detection, echo=TRUE, warning=FALSE, message=FALSE}
# Load the data using params
data <- read.csv(params$sra_runtable_path)

# Ensure relevant columns are numeric
data$ww_population <- as.numeric(data$ww_population)
data$Bases <- as.numeric(data$Bases)

# Remove rows with missing or invalid data
filtered_data <- data %>%
  filter(!is.na(ww_population), !is.na(Bases))

# Create the scatter plot
scatter_plot <- ggplot(filtered_data, aes(x = ww_population, y = Bases)) +
  geom_point(alpha = 0.7, color = "blue") +
  labs(
    title = "Relationship Between Population Size and RNA Detection",
    x = "Population Size",
    y = "RNA Detection (Bases)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title = element_text(size = 12)
  )
# Display the plot in RStudio
print(scatter_plot)
# Save the plot to a file
ggsave(filename = "population_vs_rna_detection.png", plot = scatter_plot,
       width = 10, height = 8, dpi = 300)
```
**Figure 3**:Scatter plot showing the relationship between population size and RNA detection levels (measured as bases) in wastewater samples. Each point represents a data sample, and the distribution illustrates whether population size affects RNA detection variability.

```{r Population-size-AVGspotlens, echo=FALSE}
# Create the scatter plot with regression line
avg_spotlen_plot <- ggplot(data, aes(x = ww_population, y = AvgSpotLen)) +
  geom_point(color = "blue") +
  geom_smooth(method = "lm", color = "red") +
  labs(
       title = "Relationship Between Population Size and AvgSpotLen",
       x = "Population Size",
       y = "Average Spot Length (AvgSpotLen)") +
  theme_minimal()
# Display the plot in RStudio
print(avg_spotlen_plot)
# Save the plot to a file
ggsave(filename = "population_size_avg_spotlen.png", plot = avg_spotlen_plot,
       width = 10, height = 8, dpi = 300)
```
**Figure 4**: Scatter plot showing the relationship between population size and average spot length of sequencing reads. Each blue point represents a sample, and the red regression line indicates the overall trend. The figure suggests a slight negative correlation, implying that as population size increases, the average spot length may decrease slightly. This information helps assess how population size could impact the quality of RNA sequencing in wastewater samples.

```{r boxplot-composite-grab-table, echo=FALSE}
# Load the dataset using the sra_runtable_path parameter
sra_runtable_path <- "data/00_sra_runtable/SraRunTable.csv"
data <- read.csv(sra_runtable_path)

# Create the bar plot for distribution of sampling methods
sampling_methods_plot <- ggplot(data, aes(x = ww_sample_type)) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Distribution of Sampling Methods",
    x = "Sample Type",
    y = "Count"
  ) +
  theme_minimal()

# Display the plot in RStudio
print(sampling_methods_plot)

# Save the plot to a file
ggsave(filename = "distribution_sampling_methods.png",
       plot = sampling_methods_plot, width = 10, height = 8, dpi = 300)

```
**Figure 5**: Bar plot showing the distribution of sampling methods. The majority of samples were collected using composite sampling, while grab sampling was used much less frequently.
```{r genome-bar-graph, echo=FALSE}
# Filter dataset
common_variants <- vcf_with_metadata %>%
  group_by(ref, alt) %>%
  summarize(Count = n(), .groups = "drop") %>%
  filter(Count > 500)
# Create a bar plot to visualize the reference vs. alternate genome
ggplot(common_variants, aes(x = ref, y = Count, fill = alt)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Distribution of Common Reference vs. Alternate Genome Variants",
    x = "Reference Genome",
    y = "Count of Variants",
    fill = "Alternate Genome"
  ) +
  theme_minimal() + theme(axis.text.x = element_text(angle = 45,
                                                     hjust = 1, size = 10)
)
```
**Figure 6**: Distribution of Common Reference vs. Alternate Genome Variants. This bar plot displays the counts of variants classified by their reference genome nucleotide and corresponding alternate genome variants. Variants are categorized as A, C, G, and T based on their alternate genome.

#Tables
```{r save-summary-table, echo=FALSE, warning=FALSE, message=FALSE}
# Summarize sequencing coverage by sampling method
summary_table <- vcf_with_metadata %>%
  group_by(ww_sample_matrix, ww_sample_type) %>%
  summarize(
    Mean_Coverage = mean(Bases, na.rm = TRUE),
    Median_Coverage = median(Bases, na.rm = TRUE),
    Min_Coverage = min(Bases, na.rm = TRUE),
    Max_Coverage = max(Bases, na.rm = TRUE),
    Sample_Count = n(),
    .groups = "drop"
  )

# Render the table using kable
knitr::kable(
  summary_table,
  caption = "Summary of Sequencing Coverage by Sampling Method"
)
```
**Table 1**: 

# Sources Cited
```{r devtools-cite, echo=FALSE}
devtools::session_info()
```
